/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["GLTFUtils"] = factory();
	else
		root["GLTFUtils"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/animation.ts":
/*!**************************!*\
  !*** ./src/animation.ts ***!
  \**************************/
/*! namespace exports */
/*! export Animation [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animation\": () => /* binding */ Animation\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\r\nvar Animation = /** @class */ (function () {\r\n    function Animation(path, name) {\r\n        if (name === void 0) { name = \"\"; }\r\n        this.keyframes = [];\r\n        this.name = \"\";\r\n        this.path = path;\r\n        this.name = name;\r\n    }\r\n    Animation.prototype.addKeyframe = function (time, value, interpType, extras) {\r\n        console.assert(value.length >= 3);\r\n        var kf = {\r\n            interpType: interpType,\r\n            time: time,\r\n            value: value,\r\n        };\r\n        if (interpType === _types__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode.CUBICSPLINE) {\r\n            var ext = {};\r\n            if (extras) {\r\n                if (extras.inTangent)\r\n                    ext.inTangent = extras.inTangent;\r\n                if (extras.inTangentWeight)\r\n                    ext.inTangentWeight = extras.inTangentWeight;\r\n                if (extras.outTangent)\r\n                    ext.outTangent = extras.outTangent;\r\n                if (extras.outTangentWeight)\r\n                    ext.outTangentWeight = extras.outTangentWeight;\r\n            }\r\n            if (Object.keys(ext).length > 0) {\r\n                kf.extras = ext;\r\n            }\r\n        }\r\n        this.keyframes.push(kf);\r\n    };\r\n    return Animation;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/animation.ts?");

/***/ }),

/***/ "./src/asset.ts":
/*!**********************!*\
  !*** ./src/asset.ts ***!
  \**********************/
/*! namespace exports */
/*! export GLTFAsset [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFAsset\": () => /* binding */ GLTFAsset\n/* harmony export */ });\nvar GLTFAsset = /** @class */ (function () {\r\n    function GLTFAsset() {\r\n        this.copyright = \"\";\r\n        this.defaultScene = 0;\r\n        this.generator = \"glTF-js-utils\";\r\n        this._scenes = [];\r\n    }\r\n    GLTFAsset.prototype.setDefaultScene = function (scene) {\r\n        if (typeof scene === \"number\")\r\n            this.defaultScene = scene;\r\n        else {\r\n            var sceneIndex = this._scenes.indexOf(scene);\r\n            if (sceneIndex === -1)\r\n                throw new Error(\"Scene passed to setDefaultScene was not found.\");\r\n            this.defaultScene = sceneIndex;\r\n        }\r\n    };\r\n    GLTFAsset.prototype.addScene = function (scene) {\r\n        if (this._scenes.indexOf(scene) >= 0)\r\n            throw new Error(\"Scene passed to addScene was added prior.\");\r\n        this._scenes.push(scene);\r\n    };\r\n    GLTFAsset.prototype.removeScene = function (scene) {\r\n        var sceneIndex = this._scenes.indexOf(scene);\r\n        if (sceneIndex >= 0)\r\n            this._scenes.splice(sceneIndex, 1);\r\n    };\r\n    GLTFAsset.prototype.forEachScene = function (fn) {\r\n        this._scenes.forEach(fn);\r\n    };\r\n    return GLTFAsset;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/asset.ts?");

/***/ }),

/***/ "./src/buffer.ts":
/*!***********************!*\
  !*** ./src/buffer.ts ***!
  \***********************/
/*! namespace exports */
/*! export Buffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export BufferView [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Buffer\": () => /* binding */ Buffer,\n/* harmony export */   \"BufferView\": () => /* binding */ BufferView\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\r\nvar Buffer = /** @class */ (function () {\r\n    function Buffer(gltf) {\r\n        this._bufferViews = [];\r\n        this._finalized = false;\r\n        this._gltf = gltf;\r\n        if (!gltf.buffers)\r\n            gltf.buffers = [];\r\n        this._index = gltf.buffers.length;\r\n        var gltfBuffer = {\r\n            byteLength: -1,\r\n        };\r\n        gltf.buffers.push(gltfBuffer);\r\n        this._gltfBuffer = gltfBuffer;\r\n    }\r\n    Buffer.prototype.getIndex = function () {\r\n        return this._index;\r\n    };\r\n    Buffer.prototype.addBufferView = function (componentType, dataType) {\r\n        if (this._finalizePromise)\r\n            throw new Error(\"Cannot add buffer view after finalizing buffer\");\r\n        var view = new BufferView(this, this._gltf, componentType, dataType);\r\n        this._bufferViews.push(view);\r\n        return view;\r\n    };\r\n    Buffer.prototype.getByteOffset = function (bufferView) {\r\n        var byteOffset = 0;\r\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\r\n            var view = _a[_i];\r\n            if (view === bufferView) {\r\n                return byteOffset;\r\n            }\r\n            byteOffset += view.getSize();\r\n        }\r\n        throw \"Given bufferView was not present in this buffer\";\r\n    };\r\n    Buffer.prototype.getViewFinalizePromises = function (targetBufferView) {\r\n        var promises = [];\r\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\r\n            var view = _a[_i];\r\n            if (targetBufferView && view === targetBufferView) {\r\n                return promises;\r\n            }\r\n            promises.push(view.finalized);\r\n        }\r\n        return promises;\r\n    };\r\n    Buffer.prototype.getArrayBuffer = function () {\r\n        if (!this._finalized)\r\n            throw new Error(\"Cannot get ArrayBuffer from Buffer before it is finalized\");\r\n        var byteLength = this._getTotalSize();\r\n        var buffer = new ArrayBuffer(byteLength);\r\n        var currentIndex = 0;\r\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\r\n            var bufferView = _a[_i];\r\n            bufferView.writeOutToBuffer(buffer, currentIndex);\r\n            currentIndex += bufferView.getSize();\r\n        }\r\n        return buffer;\r\n    };\r\n    Buffer.prototype.finalize = function () {\r\n        var _this = this;\r\n        if (this._finalizePromise)\r\n            throw new Error(\"Buffer \" + this._index + \" was already finalized\");\r\n        this._finalizePromise = new Promise(function (resolve) {\r\n            resolve(Promise.all(_this.getViewFinalizePromises()));\r\n        }).then(function () {\r\n            _this._finalized = true;\r\n            var arrayBuffer = _this.getArrayBuffer();\r\n            _this._gltfBuffer.byteLength = arrayBuffer.byteLength;\r\n            _this._gltfBuffer.uri = arrayBuffer; // Still not totally finalized, see stringify\r\n        });\r\n        this._gltf.extras.promises.push(this._finalizePromise);\r\n        return this._finalizePromise;\r\n    };\r\n    Buffer.prototype._getTotalSize = function () {\r\n        var byteLength = 0;\r\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\r\n            var bufferView = _a[_i];\r\n            byteLength += bufferView.getSize();\r\n        }\r\n        return byteLength;\r\n    };\r\n    return Buffer;\r\n}());\r\n\r\nvar BufferView = /** @class */ (function () {\r\n    function BufferView(buffer, gltf, componentType, dataType) {\r\n        this._data = [];\r\n        this._finalized = false;\r\n        this._accessorIndex = -1;\r\n        this._accessorAttr = null;\r\n        this._accessorMin = null;\r\n        this._accessorMax = null;\r\n        this._buffer = buffer;\r\n        this._componentType = componentType;\r\n        this._dataType = dataType;\r\n        if (!gltf.bufferViews)\r\n            gltf.bufferViews = [];\r\n        this._index = gltf.bufferViews.length;\r\n        this._gltfBufferView = {\r\n            buffer: buffer.getIndex(),\r\n            byteLength: -1,\r\n        };\r\n        var elementSize = this._getElementSize();\r\n        if (elementSize >= 4) { // Not a very good check.\r\n            this._gltfBufferView.byteStride = elementSize;\r\n        }\r\n        gltf.bufferViews.push(this._gltfBufferView);\r\n    }\r\n    BufferView.prototype.getBuffer = function () {\r\n        return this._buffer;\r\n    };\r\n    BufferView.prototype.getIndex = function () {\r\n        return this._index;\r\n    };\r\n    BufferView.prototype.push = function (item) {\r\n        var writeIndex = this._data.length;\r\n        this._data.push(item);\r\n        if (this._accessorIndex >= 0) {\r\n            var minmaxIndex = writeIndex % this._numComponentsForDataType();\r\n            if (!this._accessorMin || !this._accessorMax) {\r\n                throw new Error(\"Unexpected accessor state\");\r\n            }\r\n            var currentMin = this._accessorMin[minmaxIndex];\r\n            if (typeof currentMin !== \"number\")\r\n                this._accessorMin[minmaxIndex] = item;\r\n            else\r\n                this._accessorMin[minmaxIndex] = Math.min(currentMin, item);\r\n            var currentMax = this._accessorMax[minmaxIndex];\r\n            if (typeof currentMax !== \"number\")\r\n                this._accessorMax[minmaxIndex] = item;\r\n            else\r\n                this._accessorMax[minmaxIndex] = Math.max(currentMax, item);\r\n        }\r\n    };\r\n    BufferView.prototype.getDataSize = function () {\r\n        return this._data.length * this._sizeOfComponentType();\r\n    };\r\n    BufferView.prototype.getSize = function () {\r\n        // Technically there are some cases where the data could be more compact,\r\n        // but to be safe, we just always align each view to 4 bytes.\r\n        return makeDivisibleBy(this.getDataSize(), 4);\r\n    };\r\n    BufferView.prototype.getByteOffset = function () {\r\n        if (!this._finalized)\r\n            throw new Error(\"Cannot get BufferView offset until it is finalized\");\r\n        return this._buffer.getByteOffset(this);\r\n    };\r\n    BufferView.prototype.writeOutToBuffer = function (buffer, startIndex) {\r\n        if (startIndex === void 0) { startIndex = this.getSize(); }\r\n        var dataView = new DataView(buffer, startIndex);\r\n        var sizeOfComponentType = this._sizeOfComponentType();\r\n        for (var i = 0; i < this._data.length; i++) {\r\n            var val = this._data[i];\r\n            this._writeValue(dataView, i * sizeOfComponentType, val);\r\n        }\r\n    };\r\n    BufferView.prototype.writeAsync = function (buffer) {\r\n        var _this = this;\r\n        if (this._asyncWritePromise)\r\n            throw new Error(\"Can't write multiple buffer view values asynchronously\");\r\n        this._asyncWritePromise = buffer.then(function (arrayBuffer) {\r\n            var uintArray = new Uint8Array(arrayBuffer);\r\n            for (var i = 0; i < uintArray.byteLength; i++) {\r\n                _this._data.push(uintArray[i]);\r\n            }\r\n            delete _this._asyncWritePromise;\r\n        });\r\n        return this._asyncWritePromise;\r\n    };\r\n    BufferView.prototype.startAccessor = function (attr) {\r\n        if (attr === void 0) { attr = null; }\r\n        if (this._accessorIndex >= 0)\r\n            throw \"Accessor was started without ending the previous one\";\r\n        this._accessorIndex = this._data.length;\r\n        this._accessorAttr = attr;\r\n        this._accessorMin = new Array(this._numComponentsForDataType());\r\n        this._accessorMax = new Array(this._numComponentsForDataType());\r\n    };\r\n    BufferView.prototype.endAccessor = function () {\r\n        if (this._accessorIndex < 0)\r\n            throw new Error(\"An accessor was not started, but was attempted to be ended\");\r\n        var elementSize = this._getElementSize();\r\n        var numComponentsForDataType = this._numComponentsForDataType();\r\n        var numElements = (this._data.length - this._accessorIndex) / numComponentsForDataType;\r\n        if (numElements % 1)\r\n            throw new Error(\"An accessor was ended with missing component values\");\r\n        if (!this._accessorMin || !this._accessorMax) {\r\n            throw new Error(\"Unexpected accessor state\");\r\n        }\r\n        for (var i = 0; i < this._accessorMin.length; i++) {\r\n            if (typeof this._accessorMin[i] !== \"number\")\r\n                this._accessorMin[i] = 0;\r\n            if (typeof this._accessorMax[i] !== \"number\")\r\n                this._accessorMax[i] = 0;\r\n        }\r\n        var info = {\r\n            byteOffset: elementSize * (this._accessorIndex / numComponentsForDataType),\r\n            componentType: this._componentType,\r\n            count: numElements,\r\n            type: this._dataType,\r\n            min: this._accessorMin,\r\n            max: this._accessorMax,\r\n        };\r\n        switch (this._accessorAttr) {\r\n            case \"TEXCOORD_0\":\r\n            case \"TEXCOORD_1\":\r\n            case \"COLOR_0\":\r\n                switch (this._componentType) {\r\n                    case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE:\r\n                    case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_SHORT:\r\n                        info.normalized = true;\r\n                        break;\r\n                }\r\n                break;\r\n        }\r\n        this._accessorIndex = -1;\r\n        this._accessorAttr = null;\r\n        this._accessorMin = null;\r\n        this._accessorMax = null;\r\n        return info;\r\n    };\r\n    Object.defineProperty(BufferView.prototype, \"finalized\", {\r\n        get: function () {\r\n            var _this = this;\r\n            if (!this._finalizedPromise) {\r\n                if (this._finalized) {\r\n                    return this._finalizedPromise = Promise.resolve();\r\n                }\r\n                else {\r\n                    return this._finalizedPromise = new Promise(function (resolve) {\r\n                        _this._finalizedPromiseResolve = resolve;\r\n                    });\r\n                }\r\n            }\r\n            return this._finalizedPromise;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    BufferView.prototype.finalize = function () {\r\n        var _this = this;\r\n        var gltfBufferView = this._gltfBufferView;\r\n        return new Promise(function (resolve) {\r\n            var prereqs = _this._buffer.getViewFinalizePromises(_this);\r\n            if (_this._asyncWritePromise)\r\n                prereqs.push(_this._asyncWritePromise);\r\n            resolve(Promise.all(prereqs));\r\n        }).then(function () {\r\n            _this._finalized = true;\r\n            gltfBufferView.byteOffset = _this.getByteOffset();\r\n            gltfBufferView.byteLength = _this.getDataSize();\r\n            if (_this._finalizedPromiseResolve)\r\n                _this._finalizedPromiseResolve();\r\n        });\r\n    };\r\n    BufferView.prototype._getElementSize = function () {\r\n        return this._sizeOfComponentType() * this._numComponentsForDataType();\r\n    };\r\n    BufferView.prototype._sizeOfComponentType = function () {\r\n        switch (this._componentType) {\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.BYTE:\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE:\r\n                return 1;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.SHORT:\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_SHORT:\r\n                return 2;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_INT:\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT:\r\n                return 4;\r\n        }\r\n        throw \"Unrecognized component type \" + this._componentType;\r\n    };\r\n    BufferView.prototype._numComponentsForDataType = function () {\r\n        switch (this._dataType) {\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.SCALAR:\r\n                return 1;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC2:\r\n                return 2;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3:\r\n                return 3;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC4:\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT2:\r\n                return 4;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT3:\r\n                return 9;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT4:\r\n                return 16;\r\n        }\r\n        throw \"Unsupported data type\";\r\n    };\r\n    BufferView.prototype._writeValue = function (dataView, index, val) {\r\n        switch (this._componentType) {\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.BYTE:\r\n                dataView.setInt8(index, val);\r\n                break;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE:\r\n                dataView.setUint8(index, val);\r\n                break;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.SHORT:\r\n                dataView.setInt16(index, val, true);\r\n                break;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_SHORT:\r\n                dataView.setUint16(index, val, true);\r\n                break;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_INT:\r\n                dataView.setUint32(index, val, true);\r\n                break;\r\n            case _types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT:\r\n                dataView.setFloat32(index, val, true);\r\n                break;\r\n            default:\r\n                throw \"Unsupported data type\";\r\n        }\r\n    };\r\n    return BufferView;\r\n}());\r\n\r\nfunction makeDivisibleBy(num, by) {\r\n    return by * Math.ceil(num / by);\r\n}\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/buffer.ts?");

/***/ }),

/***/ "./src/glb.ts":
/*!********************!*\
  !*** ./src/glb.ts ***!
  \********************/
/*! namespace exports */
/*! export createGLBBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createGLBBuffer\": () => /* binding */ createGLBBuffer\n/* harmony export */ });\nvar GLB_HEADER_SIZE = 12;\r\nvar GLB_CHUNK_HEADER_SIZE = 8;\r\nvar GLB_MAGIC = 0x46546C67;\r\nvar GLTF_VERSION = 2;\r\nvar GLBChunkType;\r\n(function (GLBChunkType) {\r\n    GLBChunkType[GLBChunkType[\"JSON\"] = 1313821514] = \"JSON\";\r\n    GLBChunkType[GLBChunkType[\"BIN\"] = 5130562] = \"BIN\";\r\n})(GLBChunkType || (GLBChunkType = {}));\r\nfunction createGLBBuffer(json, bin) {\r\n    if (!json)\r\n        throw new Error(\"GLB requires a JSON glTF chunk\");\r\n    var glbLength = GLB_HEADER_SIZE;\r\n    glbLength += GLB_CHUNK_HEADER_SIZE;\r\n    var encodedJSON = textToArrayBuffer(json);\r\n    var jsonChunkSize = makeDivisibleBy(encodedJSON.byteLength, 4);\r\n    glbLength += jsonChunkSize;\r\n    if (bin) {\r\n        glbLength += GLB_CHUNK_HEADER_SIZE;\r\n        glbLength += bin.byteLength; // Already rounded\r\n        if (bin.byteLength % 4)\r\n            throw new Error(\"Expected BIN chunk length to be divisible by 4 at this point\");\r\n    }\r\n    var glbBuffer = new ArrayBuffer(glbLength);\r\n    var glbDataView = new DataView(glbBuffer);\r\n    writeHeader(glbDataView, glbLength);\r\n    // Chunk 0 (JSON)\r\n    var offset = writeChunk(glbDataView, encodedJSON, 12, GLBChunkType.JSON, 0x20);\r\n    // Chunk 1 (Binary Buffer)\r\n    if (bin) {\r\n        writeChunk(glbDataView, bin, offset, GLBChunkType.BIN);\r\n    }\r\n    return glbBuffer;\r\n}\r\nfunction writeHeader(out, glbLength) {\r\n    out.setUint32(0, GLB_MAGIC, true);\r\n    out.setUint32(4, GLTF_VERSION, true);\r\n    out.setUint32(8, glbLength, true);\r\n}\r\nfunction writeChunk(out, chunk, offset, chunkType, pad) {\r\n    if (pad === void 0) { pad = 0; }\r\n    var chunkLength = makeDivisibleBy(chunk.byteLength, 4);\r\n    out.setUint32(offset, chunkLength, true);\r\n    out.setUint32(offset += 4, chunkType, true);\r\n    writeArrayBuffer(out.buffer, chunk, offset += 4, 0, chunk.byteLength);\r\n    offset += chunk.byteLength;\r\n    while (offset % 4) {\r\n        if (pad) {\r\n            out.setUint8(offset, pad);\r\n        }\r\n        offset++;\r\n    }\r\n    return offset;\r\n}\r\nfunction textToArrayBuffer(json) {\r\n    return (new TextEncoder()).encode(json).buffer;\r\n}\r\nfunction writeArrayBuffer(target, src, targetOffset, srcOffset, byteLength) {\r\n    new Uint8Array(target, targetOffset, byteLength).set(new Uint8Array(src, srcOffset, byteLength), 0);\r\n}\r\nfunction makeDivisibleBy(num, by) {\r\n    return by * Math.ceil(num / by);\r\n}\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/glb.ts?");

/***/ }),

/***/ "./src/gltf.ts":
/*!*********************!*\
  !*** ./src/gltf.ts ***!
  \*********************/
/*! namespace exports */
/*! export addAccessor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addAnimations [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addScenes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addSkin [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createEmptyGLTF [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEmptyGLTF\": () => /* binding */ createEmptyGLTF,\n/* harmony export */   \"addScenes\": () => /* binding */ addScenes,\n/* harmony export */   \"addSkin\": () => /* binding */ addSkin,\n/* harmony export */   \"addAnimations\": () => /* binding */ addAnimations,\n/* harmony export */   \"addBuffer\": () => /* binding */ addBuffer,\n/* harmony export */   \"addAccessor\": () => /* binding */ addAccessor\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ \"./src/buffer.ts\");\n/* harmony import */ var _imageutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./imageutils */ \"./src/imageutils.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n\r\n\r\n\r\n\r\nfunction createEmptyGLTF() {\r\n    return {\r\n        asset: {\r\n            version: \"2.0\",\r\n        },\r\n        extras: {\r\n            options: {},\r\n            binChunkBuffer: null,\r\n            promises: [],\r\n            nodeIndices: new Map(),\r\n        }\r\n    };\r\n}\r\nfunction addScenes(gltf, asset) {\r\n    gltf.scene = asset.defaultScene;\r\n    var doingGLB = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB\r\n        || gltf.extras.options.imageOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.ImageOutputType.GLB;\r\n    if (doingGLB) {\r\n        gltf.extras.binChunkBuffer = addBuffer(gltf);\r\n    }\r\n    asset.forEachScene(function (scene) {\r\n        addScene(gltf, scene);\r\n    });\r\n    if (doingGLB) {\r\n        gltf.extras.binChunkBuffer.finalize();\r\n    }\r\n}\r\nfunction addScene(gltf, scene) {\r\n    if (!gltf.scenes)\r\n        gltf.scenes = [];\r\n    var gltfScene = {};\r\n    if (scene.name)\r\n        gltfScene.name = scene.name;\r\n    scene.forEachNode(function (node) {\r\n        if (!gltfScene.nodes)\r\n            gltfScene.nodes = [];\r\n        var index = addNode(gltf, node);\r\n        gltfScene.nodes.push(index);\r\n    });\r\n    gltf.scenes.push(gltfScene);\r\n}\r\nfunction addNode(gltf, node) {\r\n    var existingIndex = getNodeIndex(gltf, node);\r\n    if (existingIndex >= 0) {\r\n        return existingIndex;\r\n    }\r\n    if (!gltf.nodes)\r\n        gltf.nodes = [];\r\n    var gltfNode = {};\r\n    if (node.name)\r\n        gltfNode.name = node.name;\r\n    var translation = node.getTranslation();\r\n    if (translation.x !== 0 || translation.y !== 0 || translation.z !== 0)\r\n        gltfNode.translation = translation.toArray();\r\n    var rotation = node.getRotationQuaternion();\r\n    if (rotation.x !== 0 || rotation.y !== 0 || rotation.z !== 0 || rotation.w !== 1)\r\n        gltfNode.rotation = rotation.toArray();\r\n    var scale = node.getScale();\r\n    if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1)\r\n        gltfNode.scale = scale.toArray();\r\n    var addedIndex = gltf.nodes.length;\r\n    setNodeIndex(gltf, node, addedIndex);\r\n    gltf.nodes.push(gltfNode);\r\n    if (node.animations.length > 0) {\r\n        addAnimations(gltf, node.animations, addedIndex);\r\n    }\r\n    if (node.mesh) {\r\n        gltfNode.mesh = addMesh(gltf, node.mesh);\r\n    }\r\n    node.forEachNode(function (node) {\r\n        if (!gltfNode.children)\r\n            gltfNode.children = [];\r\n        var index = addNode(gltf, node);\r\n        gltfNode.children.push(index);\r\n    });\r\n    if (node.skin) {\r\n        gltfNode.skin = addSkin(gltf, node.skin, node);\r\n    }\r\n    return addedIndex;\r\n}\r\nfunction getJointIndexAndInverseBindMatrices(gltf, node) {\r\n    var nodeIndex = getNodeIndex(gltf, node);\r\n    if (nodeIndex === -1) {\r\n        throw new Error(\"Node should be added to gltf before calling getJointIndexAndInverseBindMatrices\");\r\n    }\r\n    var joints = [nodeIndex];\r\n    var ibms = [node.inverseBindMatrix];\r\n    node.forEachNode(function (node) {\r\n        var data = getJointIndexAndInverseBindMatrices(gltf, node);\r\n        joints = joints.concat(data[0]);\r\n        ibms = ibms.concat(data[1]);\r\n    });\r\n    return [joints, ibms];\r\n}\r\nfunction addSkin(gltf, skin, node) {\r\n    if (!gltf.skins) {\r\n        gltf.skins = [];\r\n    }\r\n    var addedIndex = gltf.skins.length;\r\n    var gltfSkin = {\r\n        joints: []\r\n    };\r\n    gltf.skins.push(gltfSkin);\r\n    // add name (if exists)\r\n    if (skin.name.length > 0)\r\n        gltfSkin.name = skin.name;\r\n    // add skeleton (if exists)\r\n    var skeletonNode = skin.skeletonNode;\r\n    if (skeletonNode) {\r\n        var existingIndex = getNodeIndex(gltf, skeletonNode);\r\n        if (existingIndex === -1) {\r\n            gltfSkin.skeleton = addNode(gltf, skeletonNode);\r\n        }\r\n        else {\r\n            gltfSkin.skeleton = existingIndex;\r\n        }\r\n    }\r\n    // add joints (required) and inversebindmatrices [IBM], if necessary\r\n    var rootNode = skeletonNode ? skeletonNode : node;\r\n    var data = getJointIndexAndInverseBindMatrices(gltf, rootNode);\r\n    gltfSkin.joints = data[0];\r\n    var ibms = data[1];\r\n    // check if there are any non default IBMs, and if so, create a new accessor\r\n    var hasIBM = false;\r\n    for (var _i = 0, ibms_1 = ibms; _i < ibms_1.length; _i++) {\r\n        var m = ibms_1[_i];\r\n        if (m && m.rows === 4 && m.cols === 4 && !_math__WEBPACK_IMPORTED_MODULE_2__.Matrix4x4.IsIdentity(m)) {\r\n            hasIBM = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!hasIBM) {\r\n        return addedIndex;\r\n    }\r\n    // init skin buffer\r\n    var singleGLBBuffer = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB;\r\n    var skinBuffer = singleGLBBuffer ? gltf.extras.binChunkBuffer : addBuffer(gltf);\r\n    // init skin bufferView\r\n    var skinBufferView = skinBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.MAT4);\r\n    // init skin accessor\r\n    skinBufferView.startAccessor();\r\n    for (var _a = 0, ibms_2 = ibms; _a < ibms_2.length; _a++) {\r\n        var ibm = ibms_2[_a];\r\n        var m = ibm instanceof _math__WEBPACK_IMPORTED_MODULE_2__.Matrix4x4 ? ibm : new _math__WEBPACK_IMPORTED_MODULE_2__.Matrix4x4();\r\n        // GLTF2.0 uses column major matrix\r\n        for (var c = 0; c < 4; c++) {\r\n            for (var r = 0; r < 4; r++) {\r\n                skinBufferView.push(m.data[r][c]);\r\n            }\r\n        }\r\n    }\r\n    // complete and clean up\r\n    var skinAccessor = skinBufferView.endAccessor();\r\n    var skinAccessor_idx = addAccessor(gltf, skinBufferView.getIndex(), skinAccessor);\r\n    gltfSkin.inverseBindMatrices = skinAccessor_idx;\r\n    skinBufferView.finalize();\r\n    if (!singleGLBBuffer)\r\n        skinBuffer.finalize();\r\n    return addedIndex;\r\n}\r\nfunction addAnimations(gltf, animations, nodeIndex) {\r\n    if (animations.length === 0)\r\n        return;\r\n    var singleGLBBuffer = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB;\r\n    var animBuffer = singleGLBBuffer ? gltf.extras.binChunkBuffer : addBuffer(gltf);\r\n    var timeBufferView = animBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.SCALAR);\r\n    var vec4BufferView; // ComponentType.FLOAT, DataType.VEC4\r\n    var vec3BufferView; // ComponentType.FLOAT, DataType.VEC3\r\n    if (!gltf.animations || gltf.animations.length === 0) {\r\n        var gltfAnim_1 = {\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        gltf.animations = [gltfAnim_1];\r\n    }\r\n    var gltfAnim = gltf.animations[0];\r\n    if (animations[0].name && !gltfAnim.name) // TODO: Animation names\r\n        gltfAnim.name = animations[0].name;\r\n    function _completeAnimation(animBufferView, interpType, path) {\r\n        var timeAccessor = timeBufferView.endAccessor();\r\n        var timeAccessor_idx = addAccessor(gltf, timeBufferView.getIndex(), timeAccessor);\r\n        var animAccessor = animBufferView.endAccessor();\r\n        var animAccessor_idx = addAccessor(gltf, animBufferView.getIndex(), animAccessor);\r\n        // then create samplers (input: times accessor idx, output: values accessor idx)\r\n        var sampler = {\r\n            \"input\": timeAccessor_idx,\r\n            \"output\": animAccessor_idx,\r\n            \"interpolation\": interpType\r\n        };\r\n        // then create channels (sampler: get sampler idx from above)\r\n        var channel = {\r\n            \"sampler\": gltfAnim.samplers.length,\r\n            \"target\": {\r\n                \"node\": nodeIndex,\r\n                \"path\": path\r\n            }\r\n        };\r\n        gltfAnim.samplers.push(sampler);\r\n        gltfAnim.channels.push(channel);\r\n    }\r\n    for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {\r\n        var anim = animations_1[_i];\r\n        if (!anim.keyframes || anim.keyframes.length == 0) {\r\n            continue;\r\n        }\r\n        // push to channels and samplers\r\n        var path = anim.path;\r\n        var isVec4 = anim.keyframes[0].value.length === 4;\r\n        var animBufferView = void 0;\r\n        if (isVec4) {\r\n            if (!vec4BufferView) {\r\n                vec4BufferView = animBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC4);\r\n            }\r\n            animBufferView = vec4BufferView;\r\n        }\r\n        else {\r\n            if (!vec3BufferView) {\r\n                vec3BufferView = animBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3);\r\n            }\r\n            animBufferView = vec3BufferView;\r\n        }\r\n        // add accessors\r\n        timeBufferView.startAccessor();\r\n        animBufferView.startAccessor();\r\n        var prev_interpType = anim.keyframes[0].interpType;\r\n        var ix = 0;\r\n        var total_kf = anim.keyframes.length;\r\n        for (var idx = 0; idx < total_kf; ++idx) {\r\n            var keyframe = anim.keyframes[idx];\r\n            var interpType = keyframe.interpType;\r\n            if (interpType != prev_interpType) {\r\n                _completeAnimation(animBufferView, prev_interpType, path);\r\n                timeBufferView.startAccessor();\r\n                animBufferView.startAccessor();\r\n                ix = 0;\r\n            }\r\n            var isSpline = interpType === _types__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode.CUBICSPLINE;\r\n            if (isSpline && isVec4)\r\n                throw new Error(\"CUBICSPLINE for Vector4 not implemented!\");\r\n            var time = keyframe.time, value = keyframe.value;\r\n            timeBufferView.push(time);\r\n            if (isSpline) {\r\n                var spline_info = keyframe.extras;\r\n                var outTangent = [0, 0, 0];\r\n                var inTangent = [0, 0, 0];\r\n                if ((spline_info === null || spline_info === void 0 ? void 0 : spline_info.inTangent) && ix > 0) {\r\n                    inTangent = spline_info.inTangent;\r\n                }\r\n                if ((spline_info === null || spline_info === void 0 ? void 0 : spline_info.outTangent) && (idx < total_kf - 1)\r\n                    && anim.keyframes[idx + 1].interpType === _types__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode.CUBICSPLINE) {\r\n                    outTangent = spline_info.outTangent;\r\n                }\r\n                var data = [inTangent, value, outTangent];\r\n                for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {\r\n                    var d = data_1[_a];\r\n                    for (var j = 0; j < 3; ++j) {\r\n                        animBufferView.push(d[j]); // aaavvvbbb, a=inTangent, v=value, b=outTangent\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var tj = isVec4 ? 4 : 3;\r\n                for (var j = 0; j < tj; ++j) {\r\n                    animBufferView.push(value[j]);\r\n                }\r\n            }\r\n            ix++;\r\n            prev_interpType = interpType;\r\n        }\r\n        _completeAnimation(animBufferView, prev_interpType, path);\r\n    }\r\n    timeBufferView.finalize();\r\n    if (vec4BufferView)\r\n        vec4BufferView.finalize();\r\n    if (vec3BufferView)\r\n        vec3BufferView.finalize();\r\n    if (!singleGLBBuffer)\r\n        animBuffer.finalize();\r\n}\r\nfunction addMesh(gltf, mesh) {\r\n    if (!gltf.meshes)\r\n        gltf.meshes = [];\r\n    if (mesh.mode !== _types__WEBPACK_IMPORTED_MODULE_0__.MeshMode.TRIANGLES)\r\n        throw \"MeshMode other than TRIANGLES not currently supported\";\r\n    addMaterials(gltf, mesh.material);\r\n    var gltfMesh = {\r\n        primitives: [],\r\n    };\r\n    var addedIndex = gltf.meshes.length;\r\n    gltf.meshes.push(gltfMesh);\r\n    var singleGLBBuffer = gltf.extras.options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_0__.BufferOutputType.GLB;\r\n    var meshBuffer;\r\n    if (singleGLBBuffer) {\r\n        meshBuffer = gltf.extras.binChunkBuffer;\r\n    }\r\n    else {\r\n        meshBuffer = addBuffer(gltf);\r\n    }\r\n    var vertexBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3);\r\n    var vertexNormalBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC3);\r\n    var vertexUVBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.FLOAT, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC2);\r\n    var vertexColorBufferView;\r\n    function _ensureColorBufferView() {\r\n        if (vertexColorBufferView)\r\n            return;\r\n        vertexColorBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.VEC4);\r\n    }\r\n    function _completeMeshPrimitive(materialIndex) {\r\n        var vertexBufferAccessorInfo = vertexBufferView.endAccessor();\r\n        var vertexNormalBufferAccessorInfo = vertexNormalBufferView.endAccessor();\r\n        var vertexUVBufferAccessorInfo = vertexUVBufferView.endAccessor();\r\n        var primitive = {\r\n            attributes: {\r\n                POSITION: addAccessor(gltf, vertexBufferView.getIndex(), vertexBufferAccessorInfo),\r\n                NORMAL: addAccessor(gltf, vertexNormalBufferView.getIndex(), vertexNormalBufferAccessorInfo),\r\n                TEXCOORD_0: addAccessor(gltf, vertexUVBufferView.getIndex(), vertexUVBufferAccessorInfo),\r\n            },\r\n            mode: mesh.mode,\r\n        };\r\n        if (materialIndex >= 0) {\r\n            primitive.material = materialIndex;\r\n            // Only add color data if it is per-face/vertex.\r\n            var material = mesh.material[materialIndex];\r\n            if (material.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.NoColors) {\r\n                var vertexColorBufferAccessorInfo = vertexColorBufferView.endAccessor();\r\n                primitive.attributes[\"COLOR_0\"] =\r\n                    addAccessor(gltf, vertexColorBufferView.getIndex(), vertexColorBufferAccessorInfo);\r\n            }\r\n        }\r\n        return primitive;\r\n    }\r\n    var lastMaterialIndex = null;\r\n    mesh.forEachFace(function (v1, v2, v3, color, materialIndex) {\r\n        var currentMaterial = null;\r\n        if (materialIndex >= 0)\r\n            currentMaterial = mesh.material[materialIndex];\r\n        // Need to start new accessors\r\n        if (lastMaterialIndex !== materialIndex) {\r\n            // And end the previous ones.\r\n            if (lastMaterialIndex !== null) {\r\n                var primitive = _completeMeshPrimitive(lastMaterialIndex);\r\n                gltfMesh.primitives.push(primitive);\r\n            }\r\n            vertexBufferView.startAccessor(\"POSITION\");\r\n            vertexNormalBufferView.startAccessor(\"NORMAL\");\r\n            vertexUVBufferView.startAccessor(\"TEXCOORD_0\");\r\n            if (currentMaterial && currentMaterial.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.NoColors) {\r\n                _ensureColorBufferView();\r\n                vertexColorBufferView.startAccessor(\"COLOR_0\");\r\n            }\r\n            lastMaterialIndex = materialIndex;\r\n        }\r\n        // Positions\r\n        vertexBufferView.push(v1.x);\r\n        vertexBufferView.push(v1.y);\r\n        vertexBufferView.push(v1.z);\r\n        vertexBufferView.push(v2.x);\r\n        vertexBufferView.push(v2.y);\r\n        vertexBufferView.push(v2.z);\r\n        vertexBufferView.push(v3.x);\r\n        vertexBufferView.push(v3.y);\r\n        vertexBufferView.push(v3.z);\r\n        // Vertex normals\r\n        vertexNormalBufferView.push(v1.normalX);\r\n        vertexNormalBufferView.push(v1.normalY);\r\n        vertexNormalBufferView.push(v1.normalZ);\r\n        vertexNormalBufferView.push(v2.normalX);\r\n        vertexNormalBufferView.push(v2.normalY);\r\n        vertexNormalBufferView.push(v2.normalZ);\r\n        vertexNormalBufferView.push(v3.normalX);\r\n        vertexNormalBufferView.push(v3.normalY);\r\n        vertexNormalBufferView.push(v3.normalZ);\r\n        // Texture UV coords\r\n        vertexUVBufferView.push(v1.u);\r\n        vertexUVBufferView.push(v1.v);\r\n        vertexUVBufferView.push(v2.u);\r\n        vertexUVBufferView.push(v2.v);\r\n        vertexUVBufferView.push(v3.u);\r\n        vertexUVBufferView.push(v3.v);\r\n        if (currentMaterial) {\r\n            // Vertex colors\r\n            switch (currentMaterial.vertexColorMode) {\r\n                case _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.FaceColors:\r\n                    // Just duplicate the face colors 3 times.\r\n                    for (var v = 0; v < 3; v++) {\r\n                        addColorToBufferView(vertexColorBufferView, color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\r\n                    }\r\n                    break;\r\n                case _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.VertexColors:\r\n                    addColorToBufferView(vertexColorBufferView, v1.color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\r\n                    addColorToBufferView(vertexColorBufferView, v2.color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\r\n                    addColorToBufferView(vertexColorBufferView, v3.color || new _types__WEBPACK_IMPORTED_MODULE_0__.RGBColor());\r\n                    break;\r\n                // NoColors? We won't have an accessor.\r\n            }\r\n        }\r\n    });\r\n    if (lastMaterialIndex !== null) {\r\n        var primitive = _completeMeshPrimitive(lastMaterialIndex);\r\n        gltfMesh.primitives.push(primitive);\r\n    }\r\n    vertexBufferView.finalize();\r\n    vertexNormalBufferView.finalize();\r\n    vertexUVBufferView.finalize();\r\n    if (vertexColorBufferView)\r\n        vertexColorBufferView.finalize();\r\n    if (!singleGLBBuffer)\r\n        meshBuffer.finalize();\r\n    return addedIndex;\r\n}\r\nfunction addColorToBufferView(bufferView, color) {\r\n    bufferView.push((color.r * 255) | 0);\r\n    bufferView.push((color.g * 255) | 0);\r\n    bufferView.push((color.b * 255) | 0);\r\n    if (\"a\" in color) {\r\n        bufferView.push((color.a * 255) | 0);\r\n    }\r\n    else {\r\n        bufferView.push(0xFF);\r\n    }\r\n}\r\nfunction addBuffer(gltf) {\r\n    return new _buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer(gltf);\r\n}\r\nfunction addAccessor(gltf, bufferViewIndex, accessorInfo) {\r\n    if (!gltf.accessors)\r\n        gltf.accessors = [];\r\n    var addedIndex = gltf.accessors.length;\r\n    var componentType = accessorInfo.componentType;\r\n    var accessor = {\r\n        bufferView: bufferViewIndex,\r\n        byteOffset: accessorInfo.byteOffset,\r\n        componentType: componentType,\r\n        count: accessorInfo.count,\r\n        type: accessorInfo.type,\r\n        min: accessorInfo.min,\r\n        max: accessorInfo.max,\r\n    };\r\n    if (accessorInfo.normalized) {\r\n        accessor.normalized = true;\r\n    }\r\n    gltf.accessors.push(accessor);\r\n    return addedIndex;\r\n}\r\nfunction addMaterials(gltf, materials) {\r\n    var indices = [];\r\n    for (var _i = 0, materials_1 = materials; _i < materials_1.length; _i++) {\r\n        var material = materials_1[_i];\r\n        indices.push(addMaterial(gltf, material));\r\n    }\r\n    return indices;\r\n}\r\nfunction addMaterial(gltf, material) {\r\n    if (!gltf.materials)\r\n        gltf.materials = [];\r\n    var gltfMaterial = {};\r\n    if (material.name)\r\n        gltfMaterial.name = material.name;\r\n    if (material.alphaMode !== _types__WEBPACK_IMPORTED_MODULE_0__.AlphaMode.OPAQUE)\r\n        gltfMaterial.alphaMode = material.alphaMode;\r\n    if (material.alphaCutoff !== 0.5)\r\n        gltfMaterial.alphaCutoff = material.alphaCutoff;\r\n    if (material.doubleSided)\r\n        gltfMaterial.doubleSided = true;\r\n    if (material.normalTexture) {\r\n        var normalIndex = addTexture(gltf, material.normalTexture);\r\n        var normalScale = material.normalTexture.scale;\r\n        gltfMaterial.normalTexture = { index: normalIndex, scale: normalScale };\r\n    }\r\n    //if (material.occlusionTexture) {\r\n    //const occlusionIndex = addTexture(gltf, material.occlusionTexture);\r\n    //const emissiveStrength = material.emissiveTexture.strength;\r\n    //gltfMaterial.occlusionTexture = { index: occlusionIndex, strength: emissiveStrength };\r\n    //}\r\n    if (material.emissiveTexture) {\r\n        var emissiveIndex = addTexture(gltf, material.emissiveTexture);\r\n        gltfMaterial.emissiveTexture = { index: emissiveIndex };\r\n    }\r\n    if (material.pbrMetallicRoughness) {\r\n        if (material.pbrMetallicRoughness.baseColorFactor) {\r\n            gltfMaterial.pbrMetallicRoughness = {};\r\n            gltfMaterial.pbrMetallicRoughness.baseColorFactor = material.pbrMetallicRoughness.baseColorFactor;\r\n        }\r\n        if (material.pbrMetallicRoughness.baseColorTexture) {\r\n            if (!gltfMaterial.pbrMetallicRoughness)\r\n                gltfMaterial.pbrMetallicRoughness = {};\r\n            var diffuseIndex = addTexture(gltf, material.pbrMetallicRoughness.baseColorTexture);\r\n            gltfMaterial.pbrMetallicRoughness.baseColorTexture = { index: diffuseIndex };\r\n        }\r\n        if (material.pbrMetallicRoughness.metallicFactor != null) {\r\n            if (!gltfMaterial.pbrMetallicRoughness)\r\n                gltfMaterial.pbrMetallicRoughness = {};\r\n            gltfMaterial.pbrMetallicRoughness.metallicFactor = material.pbrMetallicRoughness.metallicFactor;\r\n        }\r\n        if (material.pbrMetallicRoughness.roughnessFactor != null) {\r\n            if (!gltfMaterial.pbrMetallicRoughness)\r\n                gltfMaterial.pbrMetallicRoughness = {};\r\n            gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.pbrMetallicRoughness.roughnessFactor;\r\n        }\r\n        if (material.pbrMetallicRoughness.metallicRoughnessTexture != null) {\r\n            if (!gltfMaterial.pbrMetallicRoughness)\r\n                gltfMaterial.pbrMetallicRoughness = {};\r\n            var metallicRoughnessIndex = addTexture(gltf, material.pbrMetallicRoughness.metallicRoughnessTexture);\r\n            gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = { index: metallicRoughnessIndex };\r\n        }\r\n    }\r\n    var addedIndex = gltf.materials.length;\r\n    gltf.materials.push(gltfMaterial);\r\n    return addedIndex;\r\n}\r\nfunction addTexture(gltf, texture) {\r\n    if (!gltf.textures)\r\n        gltf.textures = [];\r\n    var gltfTexture = {\r\n        sampler: addSampler(gltf, texture),\r\n        source: addImage(gltf, texture.image),\r\n    };\r\n    var addedIndex = gltf.textures.length;\r\n    gltf.textures.push(gltfTexture);\r\n    return addedIndex;\r\n}\r\nfunction addImage(gltf, image) {\r\n    if (!gltf.images)\r\n        gltf.images = [];\r\n    for (var i = 0; i < gltf.images.length; i++) {\r\n        if (image === gltf.images[i].extras) {\r\n            return i; // Already had an identical image.\r\n        }\r\n    }\r\n    var gltfImage = {\r\n        extras: image,\r\n    };\r\n    var bufferView;\r\n    switch (gltf.extras.options.imageOutputType) {\r\n        case _types__WEBPACK_IMPORTED_MODULE_0__.ImageOutputType.GLB:\r\n            bufferView = gltf.extras.binChunkBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_0__.ComponentType.UNSIGNED_BYTE, _types__WEBPACK_IMPORTED_MODULE_0__.DataType.SCALAR);\r\n            bufferView.writeAsync((0,_imageutils__WEBPACK_IMPORTED_MODULE_3__.imageToArrayBuffer)(image)).then(function () {\r\n                bufferView.finalize();\r\n            });\r\n            gltfImage.bufferView = bufferView.getIndex();\r\n            gltfImage.mimeType = \"image/png\";\r\n            break;\r\n        case _types__WEBPACK_IMPORTED_MODULE_0__.ImageOutputType.DataURI:\r\n            gltfImage.uri = (0,_imageutils__WEBPACK_IMPORTED_MODULE_3__.imageToDataURI)(image);\r\n            break;\r\n        default: // ImageOutputType.External\r\n            gltf.extras.promises.push((0,_imageutils__WEBPACK_IMPORTED_MODULE_3__.imageToArrayBuffer)(image).then(function (pngBuffer) {\r\n                gltfImage.uri = pngBuffer; // Processed later\r\n            }));\r\n            break;\r\n    }\r\n    var addedIndex = gltf.images.length;\r\n    gltf.images.push(gltfImage);\r\n    return addedIndex;\r\n}\r\nfunction addSampler(gltf, texture) {\r\n    if (!gltf.samplers)\r\n        gltf.samplers = [];\r\n    var gltfSampler = {\r\n        wrapS: texture.wrapS,\r\n        wrapT: texture.wrapT,\r\n    };\r\n    for (var i = 0; i < gltf.samplers.length; i++) {\r\n        if (objectsEqual(gltfSampler, gltf.samplers[i])) {\r\n            return i; // Already had an identical sampler.\r\n        }\r\n    }\r\n    var addedIndex = gltf.samplers.length;\r\n    gltf.samplers.push(gltfSampler);\r\n    return addedIndex;\r\n}\r\nfunction getNodeIndex(gltf, node) {\r\n    if (gltf.extras.nodeIndices.has(node)) {\r\n        return gltf.extras.nodeIndices.get(node);\r\n    }\r\n    return -1;\r\n}\r\nfunction setNodeIndex(gltf, node, index) {\r\n    gltf.extras.nodeIndices.set(node, index);\r\n}\r\nfunction objectsEqual(obj1, obj2) {\r\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\r\n}\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/gltf.ts?");

/***/ }),

/***/ "./src/imageutils.ts":
/*!***************************!*\
  !*** ./src/imageutils.ts ***!
  \***************************/
/*! namespace exports */
/*! export arrayBufferIsPNG [provided] [no usage info] [missing usage info prevents renaming] */
/*! export encodeBase64DataUri [provided] [no usage info] [missing usage info prevents renaming] */
/*! export imageToArrayBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export imageToDataURI [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"imageToDataURI\": () => /* binding */ imageToDataURI,\n/* harmony export */   \"imageToArrayBuffer\": () => /* binding */ imageToArrayBuffer,\n/* harmony export */   \"encodeBase64DataUri\": () => /* binding */ encodeBase64DataUri,\n/* harmony export */   \"arrayBufferIsPNG\": () => /* binding */ arrayBufferIsPNG\n/* harmony export */ });\n/**\r\n * Converts an image into a Data URI string.\r\n * @param image\r\n */\r\nfunction imageToDataURI(image) {\r\n    var canvas = _imageTypeToCanvas(image);\r\n    return canvas.toDataURL();\r\n}\r\n/**\r\n * Converts an image into an ArrayBuffer.\r\n * @param image\r\n */\r\nfunction imageToArrayBuffer(image) {\r\n    var canvas = _imageTypeToCanvas(image);\r\n    var promiseResolve, promiseReject;\r\n    var promise = new Promise(function (resolve, reject) {\r\n        promiseResolve = resolve;\r\n        promiseReject = reject;\r\n    });\r\n    canvas.toBlob(function (blob) {\r\n        if (!blob) {\r\n            promiseReject(\"Unable to convert image to PNG\");\r\n            return;\r\n        }\r\n        var reader = new FileReader();\r\n        reader.addEventListener(\"loadend\", function () {\r\n            promiseResolve(reader.result);\r\n        });\r\n        reader.readAsArrayBuffer(blob);\r\n    }, \"image/png\");\r\n    return promise;\r\n}\r\nfunction _imageTypeToCanvas(image) {\r\n    var canvas;\r\n    if (image instanceof HTMLImageElement) {\r\n        canvas = document.createElement(\"canvas\");\r\n        canvas.width = image.width;\r\n        canvas.height = image.height;\r\n        var context_1 = canvas.getContext(\"2d\");\r\n        context_1.drawImage(image, 0, 0, image.width, image.height);\r\n    }\r\n    else {\r\n        canvas = image;\r\n    }\r\n    return canvas;\r\n}\r\n/**\r\n * Converts an ArrayBuffer into a base64 Data URI string.\r\n * @param buf\r\n */\r\nfunction encodeBase64DataUri(buf) {\r\n    var codes = [];\r\n    var uint8arr = new Uint8Array(buf);\r\n    for (var i = 0; i < uint8arr.length; i++) {\r\n        codes.push(String.fromCharCode(uint8arr[i]));\r\n    }\r\n    var b64 = btoa(codes.join(\"\"));\r\n    var uri = \"data:application/octet-stream;base64,\" + b64;\r\n    return uri;\r\n}\r\n/** Determines if an ArrayBuffer holds a PNG format image. */\r\nfunction arrayBufferIsPNG(buffer) {\r\n    // PNG starts with 89 50 4E 47 0D 0A 1A 0A\r\n    if (buffer.byteLength < 8)\r\n        return false;\r\n    var arr = new Uint8Array(buffer);\r\n    return arr[0] === 0x89\r\n        && arr[1] === 0x50\r\n        && arr[2] === 0x4E\r\n        && arr[3] === 0x47\r\n        && arr[4] === 0x0D\r\n        && arr[5] === 0x0A\r\n        && arr[6] === 0x1A\r\n        && arr[7] === 0x0A;\r\n}\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/imageutils.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! namespace exports */
/*! export AlphaMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .AlphaMode */
/*! export Animation [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/animation.ts .Animation */
/*! export Buffer [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/buffer.ts .Buffer */
/*! export BufferOutputType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .BufferOutputType */
/*! export BufferView [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/buffer.ts .BufferView */
/*! export ComponentType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .ComponentType */
/*! export DataType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .DataType */
/*! export GLTFAsset [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/asset.ts .GLTFAsset */
/*! export ImageOutputType [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .ImageOutputType */
/*! export InterpolationMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .InterpolationMode */
/*! export Material [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/material.ts .Material */
/*! export Matrix [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Matrix */
/*! export Matrix3x3 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Matrix3x3 */
/*! export Matrix4x4 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Matrix4x4 */
/*! export Mesh [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/mesh.ts .Mesh */
/*! export MeshMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .MeshMode */
/*! export Node [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/node.ts .Node */
/*! export Quaternion [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Quaternion */
/*! export RGBAColor [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .RGBAColor */
/*! export RGBColor [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .RGBColor */
/*! export Scene [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/scene.ts .Scene */
/*! export Skin [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/skin.ts .Skin */
/*! export Texture [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/texture.ts .Texture */
/*! export Transformation [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .Transformation */
/*! export Vector3 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/math.ts .Vector3 */
/*! export Vertex [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/vertex.ts .Vertex */
/*! export VertexColorMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .VertexColorMode */
/*! export WrappingMode [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/types.ts .WrappingMode */
/*! export exportGLB [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export exportGLTF [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export exportGLTFZip [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export glTFAssetFromTHREE [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] -> ./src/threejs.ts .glTFAssetFromTHREE */
/*! other exports [not provided] [maybe used in main (runtime-defined)] */
/*! runtime requirements: __webpack_require__, __webpack_exports__, __webpack_require__.d, __webpack_require__.r, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFAsset\": () => /* reexport safe */ _asset__WEBPACK_IMPORTED_MODULE_0__.GLTFAsset,\n/* harmony export */   \"Scene\": () => /* reexport safe */ _scene__WEBPACK_IMPORTED_MODULE_1__.Scene,\n/* harmony export */   \"Node\": () => /* reexport safe */ _node__WEBPACK_IMPORTED_MODULE_2__.Node,\n/* harmony export */   \"Mesh\": () => /* reexport safe */ _mesh__WEBPACK_IMPORTED_MODULE_3__.Mesh,\n/* harmony export */   \"Material\": () => /* reexport safe */ _material__WEBPACK_IMPORTED_MODULE_4__.Material,\n/* harmony export */   \"Texture\": () => /* reexport safe */ _texture__WEBPACK_IMPORTED_MODULE_5__.Texture,\n/* harmony export */   \"Vertex\": () => /* reexport safe */ _vertex__WEBPACK_IMPORTED_MODULE_6__.Vertex,\n/* harmony export */   \"Skin\": () => /* reexport safe */ _skin__WEBPACK_IMPORTED_MODULE_7__.Skin,\n/* harmony export */   \"Animation\": () => /* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_8__.Animation,\n/* harmony export */   \"Vector3\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Vector3,\n/* harmony export */   \"Quaternion\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Quaternion,\n/* harmony export */   \"Matrix\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Matrix,\n/* harmony export */   \"Matrix3x3\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Matrix3x3,\n/* harmony export */   \"Matrix4x4\": () => /* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_9__.Matrix4x4,\n/* harmony export */   \"glTFAssetFromTHREE\": () => /* reexport safe */ _threejs__WEBPACK_IMPORTED_MODULE_10__.glTFAssetFromTHREE,\n/* harmony export */   \"AlphaMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.AlphaMode,\n/* harmony export */   \"ComponentType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.ComponentType,\n/* harmony export */   \"DataType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.DataType,\n/* harmony export */   \"MeshMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.MeshMode,\n/* harmony export */   \"RGBColor\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.RGBColor,\n/* harmony export */   \"RGBAColor\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.RGBAColor,\n/* harmony export */   \"VertexColorMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.VertexColorMode,\n/* harmony export */   \"WrappingMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.WrappingMode,\n/* harmony export */   \"InterpolationMode\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.InterpolationMode,\n/* harmony export */   \"Transformation\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.Transformation,\n/* harmony export */   \"ImageOutputType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType,\n/* harmony export */   \"BufferOutputType\": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType,\n/* harmony export */   \"Buffer\": () => /* reexport safe */ _buffer__WEBPACK_IMPORTED_MODULE_12__.Buffer,\n/* harmony export */   \"BufferView\": () => /* reexport safe */ _buffer__WEBPACK_IMPORTED_MODULE_12__.BufferView,\n/* harmony export */   \"exportGLTF\": () => /* binding */ exportGLTF,\n/* harmony export */   \"exportGLTFZip\": () => /* binding */ exportGLTFZip,\n/* harmony export */   \"exportGLB\": () => /* binding */ exportGLB\n/* harmony export */ });\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \"./src/asset.ts\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ \"./src/mesh.ts\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material */ \"./src/material.ts\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture */ \"./src/texture.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vertex */ \"./src/vertex.ts\");\n/* harmony import */ var _skin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./skin */ \"./src/skin.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n/* harmony import */ var _threejs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threejs */ \"./src/threejs.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./buffer */ \"./src/buffer.ts\");\n/* harmony import */ var _gltf__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gltf */ \"./src/gltf.ts\");\n/* harmony import */ var _imageutils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./imageutils */ \"./src/imageutils.ts\");\n/* harmony import */ var _glb__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./glb */ \"./src/glb.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar MODEL_NAME_GLTF = \"model.gltf\";\r\nvar MODEL_NAME_GLB = \"model.glb\";\r\n/**\r\n * Creates a glTF model from a GLTFAsset structure.\r\n * @param asset GLTFAsset model structure\r\n * @param options Export options\r\n * @returns Promise for an object, each key pointing to a file.\r\n */\r\nfunction exportGLTF(asset, options) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var gltf, promises, currentData, currentImg, binChunkBuffer;\r\n        return __generator(this, function (_a) {\r\n            options = options || {};\r\n            gltf = (0,_gltf__WEBPACK_IMPORTED_MODULE_13__.createEmptyGLTF)();\r\n            gltf.asset.copyright = asset.copyright;\r\n            gltf.asset.generator = asset.generator;\r\n            gltf.extras.options = options;\r\n            (0,_gltf__WEBPACK_IMPORTED_MODULE_13__.addScenes)(gltf, asset);\r\n            promises = gltf.extras.promises;\r\n            currentData = 1;\r\n            currentImg = 1;\r\n            binChunkBuffer = null;\r\n            return [2 /*return*/, Promise.all(promises).then(function () {\r\n                    var output = {};\r\n                    delete gltf.extras;\r\n                    var jsonSpacing = typeof options.jsonSpacing === \"number\" ? options.jsonSpacing : 4;\r\n                    var gltfString = JSON.stringify(gltf, function (key, value) {\r\n                        if (key === \"extras\")\r\n                            return undefined;\r\n                        if (value instanceof ArrayBuffer) {\r\n                            var filename = void 0;\r\n                            if ((0,_imageutils__WEBPACK_IMPORTED_MODULE_15__.arrayBufferIsPNG)(value)) {\r\n                                switch (options.imageOutputType) {\r\n                                    case _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.DataURI:\r\n                                    case _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.GLB:\r\n                                        break; // Not applicable\r\n                                    default: // ImageOutputType.External\r\n                                        filename = \"img\" + currentImg + \".png\";\r\n                                        currentImg++;\r\n                                        output[filename] = value;\r\n                                        return filename;\r\n                                }\r\n                            }\r\n                            switch (options.bufferOutputType) {\r\n                                case _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.DataURI:\r\n                                    return (0,_imageutils__WEBPACK_IMPORTED_MODULE_15__.encodeBase64DataUri)(value);\r\n                                case _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.GLB:\r\n                                    if (binChunkBuffer)\r\n                                        throw new Error(\"Already encountered an ArrayBuffer, there should only be one in the GLB format.\");\r\n                                    binChunkBuffer = value;\r\n                                    return undefined;\r\n                                default: // BufferOutputType.External\r\n                                    filename = \"data\" + currentData + \".bin\";\r\n                                    currentData++;\r\n                                    output[filename] = value;\r\n                                    return filename;\r\n                            }\r\n                        }\r\n                        return value;\r\n                    }, jsonSpacing);\r\n                    var doingGLB = options.bufferOutputType === _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.GLB\r\n                        || options.imageOutputType === _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.GLB;\r\n                    if (doingGLB) {\r\n                        output[MODEL_NAME_GLB] = (0,_glb__WEBPACK_IMPORTED_MODULE_14__.createGLBBuffer)(gltfString, binChunkBuffer);\r\n                    }\r\n                    else {\r\n                        output[MODEL_NAME_GLTF] = gltfString;\r\n                    }\r\n                    return output;\r\n                })];\r\n        });\r\n    });\r\n}\r\n/**\r\n * Creates a ZIP file of a glTF model from a GLTFAsset structure.\r\n * @param asset GLTFAsset model structure\r\n * @param jsZip JSZip instance\r\n * @param options Export options\r\n * @returns A Promise to receive a ZIP blob is returned instead.\r\n */\r\nfunction exportGLTFZip(asset, jsZip, options) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, exportGLTF(asset, options).then(function (output) {\r\n                    var zip = new jsZip();\r\n                    for (var filename in output) {\r\n                        zip.file(filename, output[filename]);\r\n                    }\r\n                    return zip.generateAsync({ type: \"blob\" });\r\n                })];\r\n        });\r\n    });\r\n}\r\n/**\r\n * Creates a GLB binary format glTF model from a GLTFAsset structure.\r\n * @param asset GLTFAsset model structure\r\n * @returns An ArrayBuffer containing the GLB file.\r\n */\r\nfunction exportGLB(asset) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, exportGLTF(asset, {\r\n                    bufferOutputType: _types__WEBPACK_IMPORTED_MODULE_11__.BufferOutputType.GLB,\r\n                    imageOutputType: _types__WEBPACK_IMPORTED_MODULE_11__.ImageOutputType.GLB,\r\n                    jsonSpacing: 0,\r\n                }).then(function (output) {\r\n                    return output[MODEL_NAME_GLB];\r\n                })];\r\n        });\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/index.ts?");

/***/ }),

/***/ "./src/material.ts":
/*!*************************!*\
  !*** ./src/material.ts ***!
  \*************************/
/*! namespace exports */
/*! export Material [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => /* binding */ Material\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\r\nvar Material = /** @class */ (function () {\r\n    function Material() {\r\n        this.name = \"\";\r\n        this.alphaCutoff = 0.5;\r\n        this.alphaMode = _types__WEBPACK_IMPORTED_MODULE_0__.AlphaMode.OPAQUE;\r\n        this.doubleSided = false;\r\n        this.vertexColorMode = _types__WEBPACK_IMPORTED_MODULE_0__.VertexColorMode.NoColors;\r\n        this.pbrMetallicRoughness = {\r\n            metallicFactor: 1.0,\r\n            roughnessFactor: 1.0,\r\n        };\r\n    }\r\n    return Material;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/material.ts?");

/***/ }),

/***/ "./src/math.ts":
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/*! namespace exports */
/*! export Matrix [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Matrix3x3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Matrix4x4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Quaternion [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Vector3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export degreesToRadians [provided] [no usage info] [missing usage info prevents renaming] */
/*! export toQuaternion [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector3\": () => /* binding */ Vector3,\n/* harmony export */   \"Quaternion\": () => /* binding */ Quaternion,\n/* harmony export */   \"toQuaternion\": () => /* binding */ toQuaternion,\n/* harmony export */   \"degreesToRadians\": () => /* binding */ degreesToRadians,\n/* harmony export */   \"Matrix\": () => /* binding */ Matrix,\n/* harmony export */   \"Matrix3x3\": () => /* binding */ Matrix3x3,\n/* harmony export */   \"Matrix4x4\": () => /* binding */ Matrix4x4\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar Vector3 = /** @class */ (function () {\r\n    function Vector3(x, y, z) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    Vector3.prototype.toArray = function () {\r\n        return [this.x, this.y, this.z];\r\n    };\r\n    return Vector3;\r\n}());\r\n\r\nvar Quaternion = /** @class */ (function () {\r\n    function Quaternion(x, y, z, w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n    }\r\n    Quaternion.prototype.toArray = function () {\r\n        return [this.x, this.y, this.z, this.w];\r\n    };\r\n    return Quaternion;\r\n}());\r\n\r\nfunction toQuaternion(x, y, z) {\r\n    var cy = Math.cos(z * 0.5);\r\n    var sy = Math.sin(z * 0.5);\r\n    var cr = Math.cos(x * 0.5);\r\n    var sr = Math.sin(x * 0.5);\r\n    var cp = Math.cos(y * 0.5);\r\n    var sp = Math.sin(y * 0.5);\r\n    return new Quaternion(cy * sr * cp - sy * cr * sp, cy * cr * sp + sy * sr * cp, sy * cr * cp - cy * sr * sp, cy * cr * cp + sy * sr * sp);\r\n}\r\nfunction degreesToRadians(degrees) {\r\n    return degrees * Math.PI / 180;\r\n}\r\n// NxN Square Matrix\r\n// Make sure to store as row-major\r\nvar Matrix = /** @class */ (function () {\r\n    function Matrix(rows) {\r\n        if (rows === void 0) { rows = 4; }\r\n        this.data = Matrix.Identity(rows);\r\n    }\r\n    Object.defineProperty(Matrix.prototype, \"m\", {\r\n        /**\r\n         * Return the matrix values\r\n         */\r\n        get: function () {\r\n            return this.data;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Matrix.prototype, \"rows\", {\r\n        get: function () {\r\n            return this.data.length;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Matrix.prototype, \"cols\", {\r\n        get: function () {\r\n            if (this.rows === 0)\r\n                return 0;\r\n            return this.data[0].length;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initialize an identity square matrix\r\n     */\r\n    Matrix.Identity = function (rows) {\r\n        var M = [];\r\n        for (var r = 0; r < rows; ++r) {\r\n            var Mrow = [];\r\n            for (var c = 0; c < rows; ++c) {\r\n                Mrow.push(r === c ? 1 : 0);\r\n            }\r\n            M.push(Mrow);\r\n        }\r\n        return M;\r\n    };\r\n    Matrix.IsIdentity = function (matrix) {\r\n        var rows = matrix.rows;\r\n        var cols = matrix.cols;\r\n        if (rows !== cols)\r\n            return false;\r\n        for (var r = 0; r < rows; ++r) {\r\n            for (var c = 0; c < cols; ++c) {\r\n                if (matrix.data[r][c] != (r === c ? 1 : 0))\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return Matrix;\r\n}());\r\n\r\nvar Matrix3x3 = /** @class */ (function (_super) {\r\n    __extends(Matrix3x3, _super);\r\n    function Matrix3x3() {\r\n        return _super.call(this, 3) || this;\r\n    }\r\n    Matrix3x3.Identity = function () {\r\n        return Matrix.Identity(3);\r\n    };\r\n    Matrix3x3.IsIdentity = function (matrix) {\r\n        if (matrix.rows !== 3 || matrix.cols !== 3)\r\n            return false;\r\n        return Matrix.IsIdentity(matrix);\r\n    };\r\n    return Matrix3x3;\r\n}(Matrix));\r\n\r\nvar Matrix4x4 = /** @class */ (function (_super) {\r\n    __extends(Matrix4x4, _super);\r\n    function Matrix4x4() {\r\n        return _super.call(this, 4) || this;\r\n    }\r\n    Matrix4x4.Identity = function () {\r\n        return Matrix.Identity(4);\r\n    };\r\n    Matrix4x4.IsIdentity = function (matrix) {\r\n        if (matrix.rows !== 4 || matrix.cols !== 4)\r\n            return false;\r\n        return Matrix.IsIdentity(matrix);\r\n    };\r\n    return Matrix4x4;\r\n}(Matrix));\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/math.ts?");

/***/ }),

/***/ "./src/mesh.ts":
/*!*********************!*\
  !*** ./src/mesh.ts ***!
  \*********************/
/*! namespace exports */
/*! export Mesh [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mesh\": () => /* binding */ Mesh\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\r\nvar Mesh = /** @class */ (function () {\r\n    function Mesh() {\r\n        this.material = [];\r\n        this.mode = _types__WEBPACK_IMPORTED_MODULE_0__.MeshMode.TRIANGLES;\r\n        this._vertices = [];\r\n        this._faceColors = [];\r\n        this._materialIndices = [];\r\n    }\r\n    Mesh.prototype.addFace = function (v1, v2, v3, color, materialIndex) {\r\n        this._vertices.push(v1);\r\n        this._vertices.push(v2);\r\n        this._vertices.push(v3);\r\n        this._faceColors.push(color);\r\n        if (typeof materialIndex === \"undefined\")\r\n            materialIndex = -1;\r\n        this._materialIndices.push(materialIndex);\r\n    };\r\n    Mesh.prototype.forEachFace = function (fn) {\r\n        for (var i = 0; i < this._vertices.length / 3; i++) {\r\n            fn(this._vertices[(i * 3)], this._vertices[(i * 3) + 1], this._vertices[(i * 3) + 2], this._faceColors[i], this._materialIndices[i]);\r\n        }\r\n    };\r\n    return Mesh;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/mesh.ts?");

/***/ }),

/***/ "./src/node.ts":
/*!*********************!*\
  !*** ./src/node.ts ***!
  \*********************/
/*! namespace exports */
/*! export Node [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Node\": () => /* binding */ Node\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animation */ \"./src/animation.ts\");\n\r\n\r\nvar Node = /** @class */ (function () {\r\n    function Node(name) {\r\n        if (name === void 0) { name = \"\"; }\r\n        this.name = \"\";\r\n        this.animations = [];\r\n        this._nodes = [];\r\n        this.name = name;\r\n    }\r\n    Node.prototype.addNode = function (node) {\r\n        if (this._nodes.indexOf(node) >= 0)\r\n            return;\r\n        // throw new Error(\"Node passed to addNode was added prior.\");\r\n        this._nodes.push(node);\r\n    };\r\n    Node.prototype.removeNode = function (node) {\r\n        var idx = node instanceof Node ? this._nodes.indexOf(node) : node;\r\n        if (idx >= 0 && idx < this._nodes.length)\r\n            this._nodes.splice(idx, 1);\r\n        return idx;\r\n    };\r\n    Node.prototype.forEachNode = function (fn) {\r\n        this._nodes.forEach(fn);\r\n    };\r\n    Node.prototype.addAnimation = function (animation) {\r\n        this.animations.push(animation);\r\n    };\r\n    Node.prototype.removeAnimation = function (animation) {\r\n        var idx = animation instanceof _animation__WEBPACK_IMPORTED_MODULE_1__.Animation ? this.animations.indexOf(animation) : animation;\r\n        if (idx >= 0 && idx < this.animations.length)\r\n            this.animations.splice(idx, 1);\r\n        return idx;\r\n    };\r\n    Node.prototype.setTranslation = function (x, y, z) {\r\n        this._translation = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);\r\n    };\r\n    Node.prototype.getTranslation = function () {\r\n        return this._translation || new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\r\n    };\r\n    Node.prototype.setRotationDegrees = function (x, y, z) {\r\n        this.setRotationRadians((0,_math__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(x), (0,_math__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(y), (0,_math__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(z));\r\n    };\r\n    Node.prototype.setRotationRadians = function (x, y, z) {\r\n        this._rotation = (0,_math__WEBPACK_IMPORTED_MODULE_0__.toQuaternion)(x, y, z);\r\n    };\r\n    Node.prototype.setRotationQuaternion = function (x, y, z, w) {\r\n        this._rotation = new _math__WEBPACK_IMPORTED_MODULE_0__.Quaternion(x, y, z, w);\r\n    };\r\n    Node.prototype.getRotationQuaternion = function () {\r\n        return this._rotation || new _math__WEBPACK_IMPORTED_MODULE_0__.Quaternion(0, 0, 0, 1);\r\n    };\r\n    Node.prototype.setScale = function (x, y, z) {\r\n        this._scale = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);\r\n    };\r\n    Node.prototype.getScale = function () {\r\n        return this._scale || new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\r\n    };\r\n    return Node;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/node.ts?");

/***/ }),

/***/ "./src/scene.ts":
/*!**********************!*\
  !*** ./src/scene.ts ***!
  \**********************/
/*! namespace exports */
/*! export Scene [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => /* binding */ Scene\n/* harmony export */ });\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n\r\nvar Scene = /** @class */ (function () {\r\n    function Scene(name) {\r\n        if (name === void 0) { name = \"\"; }\r\n        this.name = \"\";\r\n        this._nodes = [];\r\n        this.name = name;\r\n    }\r\n    Scene.prototype.addNode = function (node) {\r\n        if (this._nodes.indexOf(node) >= 0)\r\n            return;\r\n        // throw new Error(\"Node passed to addNode was added prior.\");\r\n        this._nodes.push(node);\r\n    };\r\n    Scene.prototype.removeNode = function (node) {\r\n        var idx = node instanceof _node__WEBPACK_IMPORTED_MODULE_0__.Node ? this._nodes.indexOf(node) : node;\r\n        if (idx >= 0 && idx < this._nodes.length)\r\n            this._nodes.splice(idx, 1);\r\n        return idx;\r\n    };\r\n    Scene.prototype.forEachNode = function (fn) {\r\n        this._nodes.forEach(fn);\r\n    };\r\n    return Scene;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/scene.ts?");

/***/ }),

/***/ "./src/skin.ts":
/*!*********************!*\
  !*** ./src/skin.ts ***!
  \*********************/
/*! namespace exports */
/*! export Skin [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Skin\": () => /* binding */ Skin\n/* harmony export */ });\nvar Skin = /** @class */ (function () {\r\n    function Skin(skeletonNode, name) {\r\n        if (skeletonNode === void 0) { skeletonNode = null; }\r\n        if (name === void 0) { name = \"\"; }\r\n        this.name = \"\";\r\n        this.skeletonNode = skeletonNode;\r\n        this.name = name;\r\n    }\r\n    return Skin;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/skin.ts?");

/***/ }),

/***/ "./src/texture.ts":
/*!************************!*\
  !*** ./src/texture.ts ***!
  \************************/
/*! namespace exports */
/*! export Texture [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Texture\": () => /* binding */ Texture\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\r\nvar Texture = /** @class */ (function () {\r\n    function Texture(image) {\r\n        this.wrapS = _types__WEBPACK_IMPORTED_MODULE_0__.WrappingMode.CLAMP_TO_EDGE;\r\n        this.wrapT = _types__WEBPACK_IMPORTED_MODULE_0__.WrappingMode.CLAMP_TO_EDGE;\r\n        this.scale = 1;\r\n        this.image = image;\r\n    }\r\n    Object.defineProperty(Texture.prototype, \"image\", {\r\n        get: function () {\r\n            return this.__image;\r\n        },\r\n        set: function (val) {\r\n            if (!val) {\r\n                throw new Error(\"Why is the texture image being unset?\");\r\n            }\r\n            this.__image = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Texture;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/texture.ts?");

/***/ }),

/***/ "./src/threejs.ts":
/*!************************!*\
  !*** ./src/threejs.ts ***!
  \************************/
/*! namespace exports */
/*! export glTFAssetFromTHREE [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"glTFAssetFromTHREE\": () => /* binding */ glTFAssetFromTHREE\n/* harmony export */ });\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \"./src/asset.ts\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ \"./src/mesh.ts\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material */ \"./src/material.ts\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture */ \"./src/texture.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vertex */ \"./src/vertex.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction glTFAssetFromTHREE(obj) {\r\n    var asset = new _asset__WEBPACK_IMPORTED_MODULE_0__.GLTFAsset();\r\n    var scene = new _scene__WEBPACK_IMPORTED_MODULE_1__.Scene();\r\n    scene.name = obj.name;\r\n    asset.addScene(scene);\r\n    scene.addNode(NodeFromTHREE(obj));\r\n    return asset;\r\n}\r\nfunction NodeFromTHREE(obj) {\r\n    var node = new _node__WEBPACK_IMPORTED_MODULE_2__.Node();\r\n    node.name = obj.name;\r\n    if (isTHREEMesh(obj)) {\r\n        node.mesh = MeshFromTHREE(obj);\r\n    }\r\n    else {\r\n        node.setTranslation(obj.position.x, obj.position.y, obj.position.z);\r\n        node.setRotationRadians(obj.rotation.x, obj.rotation.y, obj.rotation.z);\r\n        node.setScale(obj.scale.x, obj.scale.y, obj.scale.z);\r\n        for (var _i = 0, _a = obj.children; _i < _a.length; _i++) {\r\n            var child = _a[_i];\r\n            node.addNode(NodeFromTHREE(child));\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction MeshFromTHREE(obj) {\r\n    var mesh = new _mesh__WEBPACK_IMPORTED_MODULE_3__.Mesh();\r\n    var threeGeometry = obj.geometry;\r\n    if (isTHREEGeometry(threeGeometry)) {\r\n        for (var i = 0; i < threeGeometry.faces.length; i++) {\r\n            var face = threeGeometry.faces[i];\r\n            var faceColor = new _types__WEBPACK_IMPORTED_MODULE_7__.RGBColor();\r\n            faceColor.r = face.color.r;\r\n            faceColor.g = face.color.g;\r\n            faceColor.b = face.color.b;\r\n            mesh.addFace(VertexFromTHREE(threeGeometry, i, face.a, 0), VertexFromTHREE(threeGeometry, i, face.b, 1), VertexFromTHREE(threeGeometry, i, face.c, 2), faceColor, face.materialIndex);\r\n        }\r\n        mesh.material = MaterialsFromTHREE(obj.material);\r\n    }\r\n    else {\r\n        throw new Error(\"BufferGeometry (or other type) not supported.\");\r\n    }\r\n    return mesh;\r\n}\r\nfunction MaterialsFromTHREE(threeMaterial) {\r\n    var materials = [];\r\n    if (!Array.isArray(threeMaterial)) {\r\n        threeMaterial = [threeMaterial];\r\n    }\r\n    for (var _i = 0, threeMaterial_1 = threeMaterial; _i < threeMaterial_1.length; _i++) {\r\n        var mat = threeMaterial_1[_i];\r\n        materials.push(MaterialFromTHREE(mat));\r\n    }\r\n    return materials;\r\n}\r\nfunction MaterialFromTHREE(threeMaterial) {\r\n    var material = new _material__WEBPACK_IMPORTED_MODULE_4__.Material();\r\n    material.doubleSided = threeMaterial.side === 2; // THREE.DoubleSide;\r\n    if (isTHREEMeshBasicMaterial(threeMaterial)) {\r\n        material.pbrMetallicRoughness.metallicFactor = 0;\r\n        material.pbrMetallicRoughness.roughnessFactor = 0;\r\n        if (threeMaterial.transparent) {\r\n            material.alphaMode = _types__WEBPACK_IMPORTED_MODULE_7__.AlphaMode.MASK;\r\n            material.alphaCutoff = threeMaterial.alphaTest;\r\n        }\r\n        material.vertexColorMode = threeMaterial.vertexColors ? _types__WEBPACK_IMPORTED_MODULE_7__.VertexColorMode.VertexColors : _types__WEBPACK_IMPORTED_MODULE_7__.VertexColorMode.NoColors;\r\n        if (threeMaterial.color && !threeMaterial.vertexColors) {\r\n            material.pbrMetallicRoughness.baseColorFactor = [\r\n                threeMaterial.color.r,\r\n                threeMaterial.color.g,\r\n                threeMaterial.color.b,\r\n                1\r\n            ];\r\n        }\r\n        if (threeMaterial.map) {\r\n            var texture = new _texture__WEBPACK_IMPORTED_MODULE_5__.Texture(threeMaterial.map.image);\r\n            texture.wrapS = WrappingModeFromTHREE(threeMaterial.map.wrapS);\r\n            texture.wrapT = WrappingModeFromTHREE(threeMaterial.map.wrapT);\r\n            material.pbrMetallicRoughness.baseColorTexture = texture;\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(threeMaterial.type + \" is currently not supported.\");\r\n    }\r\n    return material;\r\n}\r\nfunction VertexFromTHREE(threeGeometry, faceIndex, vertexIndex, vertexRelIndex) {\r\n    var vertex = new _vertex__WEBPACK_IMPORTED_MODULE_6__.Vertex();\r\n    var threeVertex = threeGeometry.vertices[vertexIndex];\r\n    vertex.x = threeVertex.x;\r\n    vertex.y = threeVertex.y;\r\n    vertex.z = threeVertex.z;\r\n    if (threeGeometry.faceVertexUvs[0] && threeGeometry.faceVertexUvs[0][faceIndex]\r\n        && threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex]) {\r\n        vertex.u = threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex].x;\r\n        vertex.v = threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex].y;\r\n    }\r\n    var threeFace = threeGeometry.faces[faceIndex];\r\n    if (threeFace.vertexNormals[vertexRelIndex]) {\r\n        vertex.normalX = threeFace.vertexNormals[vertexRelIndex].x;\r\n        vertex.normalY = threeFace.vertexNormals[vertexRelIndex].y;\r\n        vertex.normalZ = threeFace.vertexNormals[vertexRelIndex].z;\r\n    }\r\n    if (threeFace.vertexColors[vertexRelIndex]) {\r\n        vertex.color = new _types__WEBPACK_IMPORTED_MODULE_7__.RGBColor();\r\n        vertex.color.r = threeFace.vertexColors[vertexRelIndex].r;\r\n        vertex.color.g = threeFace.vertexColors[vertexRelIndex].g;\r\n        vertex.color.b = threeFace.vertexColors[vertexRelIndex].b;\r\n    }\r\n    return vertex;\r\n}\r\nfunction WrappingModeFromTHREE(mode) {\r\n    switch (mode) {\r\n        case 1000: // THREE.RepeatWrapping\r\n            return _types__WEBPACK_IMPORTED_MODULE_7__.WrappingMode.REPEAT;\r\n        case 1002: // THREE.MirroredRepeatWrapping\r\n            return _types__WEBPACK_IMPORTED_MODULE_7__.WrappingMode.MIRRORED_REPEAT;\r\n        case 1001: // THREE.ClampToEdgeWrapping\r\n        default:\r\n            return _types__WEBPACK_IMPORTED_MODULE_7__.WrappingMode.CLAMP_TO_EDGE;\r\n    }\r\n}\r\nfunction isTHREEMesh(obj) {\r\n    return obj.type === \"Mesh\";\r\n}\r\nfunction isTHREEGeometry(obj) {\r\n    return obj.type === \"Geometry\";\r\n}\r\nfunction isTHREEMeshBasicMaterial(obj) {\r\n    return obj.type === \"MeshBasicMaterial\";\r\n}\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/threejs.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/*! namespace exports */
/*! export AlphaMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export BufferOutputType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ComponentType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DataType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ImageOutputType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export InterpolationMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MeshMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RGBAColor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RGBColor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Transformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export VertexColorMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WrappingMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BufferOutputType\": () => /* binding */ BufferOutputType,\n/* harmony export */   \"ImageOutputType\": () => /* binding */ ImageOutputType,\n/* harmony export */   \"ComponentType\": () => /* binding */ ComponentType,\n/* harmony export */   \"DataType\": () => /* binding */ DataType,\n/* harmony export */   \"MeshMode\": () => /* binding */ MeshMode,\n/* harmony export */   \"WrappingMode\": () => /* binding */ WrappingMode,\n/* harmony export */   \"AlphaMode\": () => /* binding */ AlphaMode,\n/* harmony export */   \"RGBColor\": () => /* binding */ RGBColor,\n/* harmony export */   \"RGBAColor\": () => /* binding */ RGBAColor,\n/* harmony export */   \"VertexColorMode\": () => /* binding */ VertexColorMode,\n/* harmony export */   \"InterpolationMode\": () => /* binding */ InterpolationMode,\n/* harmony export */   \"Transformation\": () => /* binding */ Transformation\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar BufferOutputType;\r\n(function (BufferOutputType) {\r\n    /** Create separate files for binary buffers (default) */\r\n    BufferOutputType[BufferOutputType[\"External\"] = 0] = \"External\";\r\n    /** Embed buffers as data URIs. */\r\n    BufferOutputType[BufferOutputType[\"DataURI\"] = 1] = \"DataURI\";\r\n    /**\r\n     * Embed buffers as chunks in a GLB buffer.\r\n     */\r\n    BufferOutputType[BufferOutputType[\"GLB\"] = 2] = \"GLB\";\r\n})(BufferOutputType || (BufferOutputType = {}));\r\nvar ImageOutputType;\r\n(function (ImageOutputType) {\r\n    /** Create separate files for images (default) */\r\n    ImageOutputType[ImageOutputType[\"External\"] = 0] = \"External\";\r\n    /** Embed images as data URIs. */\r\n    ImageOutputType[ImageOutputType[\"DataURI\"] = 1] = \"DataURI\";\r\n    /**\r\n     * Embed images as chunks in a GLB buffer.\r\n     */\r\n    ImageOutputType[ImageOutputType[\"GLB\"] = 2] = \"GLB\";\r\n})(ImageOutputType || (ImageOutputType = {}));\r\nvar ComponentType;\r\n(function (ComponentType) {\r\n    ComponentType[ComponentType[\"BYTE\"] = 5120] = \"BYTE\";\r\n    ComponentType[ComponentType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\r\n    ComponentType[ComponentType[\"SHORT\"] = 5122] = \"SHORT\";\r\n    ComponentType[ComponentType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\r\n    ComponentType[ComponentType[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\r\n    ComponentType[ComponentType[\"FLOAT\"] = 5126] = \"FLOAT\";\r\n})(ComponentType || (ComponentType = {}));\r\nvar DataType;\r\n(function (DataType) {\r\n    DataType[\"SCALAR\"] = \"SCALAR\";\r\n    DataType[\"VEC2\"] = \"VEC2\";\r\n    DataType[\"VEC3\"] = \"VEC3\";\r\n    DataType[\"VEC4\"] = \"VEC4\";\r\n    DataType[\"MAT2\"] = \"MAT2\";\r\n    DataType[\"MAT3\"] = \"MAT3\";\r\n    DataType[\"MAT4\"] = \"MAT4\";\r\n})(DataType || (DataType = {}));\r\nvar MeshMode;\r\n(function (MeshMode) {\r\n    MeshMode[MeshMode[\"POINTS\"] = 0] = \"POINTS\";\r\n    MeshMode[MeshMode[\"LINES\"] = 1] = \"LINES\";\r\n    MeshMode[MeshMode[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\r\n    MeshMode[MeshMode[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\r\n    MeshMode[MeshMode[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\r\n    MeshMode[MeshMode[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\r\n    MeshMode[MeshMode[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\r\n})(MeshMode || (MeshMode = {}));\r\nvar WrappingMode;\r\n(function (WrappingMode) {\r\n    WrappingMode[WrappingMode[\"CLAMP_TO_EDGE\"] = 33071] = \"CLAMP_TO_EDGE\";\r\n    WrappingMode[WrappingMode[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\r\n    WrappingMode[WrappingMode[\"REPEAT\"] = 10497] = \"REPEAT\";\r\n})(WrappingMode || (WrappingMode = {}));\r\nvar AlphaMode;\r\n(function (AlphaMode) {\r\n    AlphaMode[\"OPAQUE\"] = \"OPAQUE\";\r\n    AlphaMode[\"MASK\"] = \"MASK\";\r\n    AlphaMode[\"BLEND\"] = \"BLEND\";\r\n})(AlphaMode || (AlphaMode = {}));\r\nvar RGBColor = /** @class */ (function () {\r\n    function RGBColor() {\r\n        /** Red, between 0 and 1. */\r\n        this.r = 1;\r\n        /** Green, between 0 and 1 */\r\n        this.g = 1;\r\n        /** Blue, between 0 and 1 */\r\n        this.b = 1;\r\n    }\r\n    return RGBColor;\r\n}());\r\n\r\nvar RGBAColor = /** @class */ (function (_super) {\r\n    __extends(RGBAColor, _super);\r\n    function RGBAColor() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /** Alpha, between 0 and 1 */\r\n        _this.a = 1;\r\n        return _this;\r\n    }\r\n    return RGBAColor;\r\n}(RGBColor));\r\n\r\n// Matches THREE Colors\r\nvar VertexColorMode;\r\n(function (VertexColorMode) {\r\n    VertexColorMode[VertexColorMode[\"NoColors\"] = 0] = \"NoColors\";\r\n    VertexColorMode[VertexColorMode[\"FaceColors\"] = 1] = \"FaceColors\";\r\n    VertexColorMode[VertexColorMode[\"VertexColors\"] = 2] = \"VertexColors\";\r\n})(VertexColorMode || (VertexColorMode = {}));\r\nvar InterpolationMode;\r\n(function (InterpolationMode) {\r\n    InterpolationMode[\"LINEAR\"] = \"LINEAR\";\r\n    InterpolationMode[\"STEP\"] = \"STEP\";\r\n    InterpolationMode[\"CUBICSPLINE\"] = \"CUBICSPLINE\";\r\n})(InterpolationMode || (InterpolationMode = {}));\r\nvar Transformation;\r\n(function (Transformation) {\r\n    Transformation[\"TRANSLATION\"] = \"translation\";\r\n    Transformation[\"ROTATION\"] = \"rotation\";\r\n    Transformation[\"SCALE\"] = \"scale\";\r\n})(Transformation || (Transformation = {}));\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/types.ts?");

/***/ }),

/***/ "./src/vertex.ts":
/*!***********************!*\
  !*** ./src/vertex.ts ***!
  \***********************/
/*! namespace exports */
/*! export Vertex [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vertex\": () => /* binding */ Vertex\n/* harmony export */ });\nvar Vertex = /** @class */ (function () {\r\n    function Vertex() {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.u = 0;\r\n        this.v = 0;\r\n        this.normalX = 0;\r\n        this.normalY = 0;\r\n        this.normalZ = 0;\r\n    }\r\n    return Vertex;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://GLTFUtils/./src/vertex.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/index.ts");
/******/ })()
;
});